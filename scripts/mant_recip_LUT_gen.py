#!/usr/bin/env python3
"""
Generation of LUT with 2**LUT_IN entries and LUT_OUT output bits
representing, in the format Fx<0, LUT_OUT_BITS> the reciprocate of the input.
Checkout the companion notebook for a better visualization of what's going on.

./mant_recip_LUT_gen.py -i 8 -o 9 > lut.sv
"""

import argparse
from fixed2float import Fx, to_Fx

parser = argparse.ArgumentParser(description="Generate LUT")

parser.add_argument("--size-in", "-i", type=int, required=True, help="Input width")
parser.add_argument("--size-out", "-o", type=int, required=True, help="Output width")

args = parser.parse_args()
LUT_IN = args.size_in
LUT_OUT = args.size_out


lut = dict()


def compute_frac_recip_val(frac):
    """
    frac_val:  .ffffff

    ans: .ffff
    """
    if frac == 0:
        return 0

    fx_mant = Fx(frac | (1 << LUT_IN), 1, LUT_IN + 1)

    fx_mant_only_fractional = to_Fx(fx_mant.eval() - 1.0, 0, LUT_IN, round=True)

    fx_mant_recip = to_Fx(1.0 / fx_mant.eval(), 0, 0 + LUT_OUT, round=True)

    lut[fx_mant_only_fractional.val] = fx_mant_recip.val
    return fx_mant_recip.val


SPACES = " " * 6
lut_content = ""
for frac in range(0, 1 << LUT_IN):
    lut_content += f"{SPACES}{LUT_IN}'d{frac} :    dout = {LUT_OUT}'h{hex(compute_frac_recip_val(frac)).replace('0x','')};\n"


print(
    f"""
/***************************************************************
*** autogenerated by $PPU_ROOT/scripts/mant_recip_LUT_gen.py ***
***************************************************************/
module lut_reciprocate #(
  parameter LUT_WIDTH_IN = {LUT_IN},
  parameter LUT_WIDTH_OUT = {LUT_OUT}
)(
  input   [(LUT_WIDTH_IN)-1:0]    addr_i,
  output  [(LUT_WIDTH_OUT)-1:0]   out_o
);

  logic [(LUT_WIDTH_OUT)-1:0] dout;
  logic [(LUT_WIDTH_OUT)-1:0] mant_recip_rom [(2**LUT_WIDTH_IN) - 1:0];

  always_comb begin
    case (addr_i)
    {lut_content}
      default: dout = 'h0;
    endcase
  end

  assign out_o = dout; // << 1;
endmodule: lut_reciprocate
"""
)
